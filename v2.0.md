# marpc v2.0 — 方法重载、类型转换、注册中心、负载均衡

## 版本概述

v2.0 在 v1.0 基础上实现了生产级 RPC 框架的核心能力：

1. **方法签名规范化**：解决方法重载歧义，支持同名不同参数的方法调用
2. **参数类型转换**：Provider 端根据方法签名将 JSON 反序列化参数转换为正确的 Java 类型
3. **动态服务注册**：接入 Zookeeper 注册中心，Provider 启动时注册，Consumer 动态发现
4. **负载均衡**：支持轮询（RoundRobin）和随机（Random）策略，Consumer 自动分发请求到多实例
5. **服务订阅**：Consumer 订阅注册中心变更，实例上下线时自动刷新服务列表

## 代码结构

```
marpc/
├── src/main/java/com/malinghan/marpc/
│   ├── MarpcApplication.java              # 启动类（已移至根包）
│   ├── annotation/                        # 注解定义
│   │   ├── EnableMarpc.java               # 启用框架
│   │   ├── MarpcProvider.java             # 标记服务提供方
│   │   └── MarpcConsumer.java             # 标记服务消费方
│   ├── config/
│   │   └── MarpcConfig.java               # Spring 配置（注册中心、负载均衡）
│   ├── core/                              # 协议定义
│   │   ├── RpcRequest.java                # 请求协议（新增 methodSign）
│   │   └── RpcResponse.java               # 响应协议
│   ├── provider/
│   │   └── ProviderBootstrap.java         # Provider 启动引导（注册服务、方法匹配、类型转换）
│   ├── consumer/
│   │   ├── ConsumerBootstrap.java         # Consumer 启动引导（订阅服务、注入代理）
│   │   └── MarpcInvocationHandler.java    # 动态代理（生成方法签名、负载均衡）
│   ├── registry/                          # 注册中心
│   │   ├── RegistryCenter.java            # 注册中心接口
│   │   └── ZkRegistryCenter.java          # Zookeeper 实现
│   ├── loadbalance/                       # 负载均衡
│   │   ├── LoadBalancer.java              # 负载均衡接口
│   │   ├── RoundRobinLoadBalancer.java    # 轮询实现
│   │   └── RandomLoadBalancer.java        # 随机实现
│   ├── transport/
│   │   └── MarpcTransport.java            # HTTP 传输层
│   └── demo/                              # 示例服务
│       ├── HelloService.java              # 服务接口（含重载方法）
│       ├── HelloServiceImpl.java          # 服务实现
│       └── User.java                      # 自定义对象
└── src/test/java/com/malinghan/marpc/
    ├── provider/
    │   ├── ProviderBootstrapTest.java     # Provider 单元测试
    │   └── ProviderBootstrapV2Test.java   # v2.0 集成测试
    ├── consumer/
    │   └── MarpcInvocationHandlerTest.java
    └── transport/
        └── MarpcTransportTest.java
```

## 核心功能

### 1. 方法签名规范化

**问题**：v1.0 只按方法名 + 参数个数匹配，无法区分 `hello(String)` 和 `hello(String, int)` 这类重载方法。

**解决方案**：
- **签名格式**：`methodName@paramCount_type1_type2`
  - 示例：`hello@1_java.lang.String`、`hello@2_java.lang.String_int`
- **Consumer 端**：`MarpcInvocationHandler.buildMethodSign(Method)` 自动生成签名并填充到 `RpcRequest.methodSign`
- **Provider 端**：`ProviderBootstrap.findMethod` 优先按签名精确匹配，签名为空时回退到 v1.0 的名称+参数个数匹配（兼容旧请求）

```java
// Consumer 端生成签名
private String buildMethodSign(Method method) {
    Class<?>[] params = method.getParameterTypes();
    if (params.length == 0) return method.getName() + "@0";
    String types = Arrays.stream(params)
            .map(Class::getCanonicalName)
            .collect(Collectors.joining("_"));
    return method.getName() + "@" + params.length + "_" + types;
}

// Provider 端匹配
private Method findMethod(Class<?> clazz, String methodSign, String methodName) {
    if (methodSign != null && !methodSign.isEmpty()) {
        for (Method m : clazz.getMethods()) {
            if (buildSign(m).equals(methodSign)) return m;
        }
    }
    // fallback: 按名称+参数个数
    ...
}
```

### 2. 参数类型转换

**问题**：JSON 反序列化后，参数类型可能不匹配方法声明（如 `int` 变成 `Integer`、`List<String>` 变成 `JSONArray`）。

**解决方案**：Provider 端 `convertArgs` 根据方法签名将参数转换为正确类型。

```java
private Object[] convertArgs(Method method, Object[] args) {
    if (args == null || args.length == 0) return args;
    Class<?>[] paramTypes = method.getParameterTypes();
    Object[] result = new Object[args.length];
    for (int i = 0; i < args.length; i++) {
        result[i] = JSON.to(paramTypes[i], args[i]);
    }
    return result;
}
```

**支持类型**：
- 基本类型及包装类：`int/Integer`、`long/Long`、`boolean/Boolean` 等
- 集合类型：`List<T>`、`Map<K,V>`
- 自定义对象：`User`、`Order` 等 POJO

### 3. 动态服务注册

**架构**：
```
Provider                    Zookeeper                    Consumer
   |                           |                            |
   |-- register(service) ----->|                            |
   |   /app_env_HelloService   |                            |
   |   └─ localhost_8080       |                            |
   |                           |<---- fetchAll(service) ----|
   |                           |                            |
   |                           |<---- subscribe(service) ---|
   |                           |                            |
   |-- unregister() ---------->|                            |
   |   (优雅关闭)               |---- onChange(instances) -->|
```

**注册路径规范**：`/{app}_{env}_{serviceName}/{host_port}`
- 示例：`/marpc-app_dev_com.malinghan.marpc.demo.HelloService/localhost_8080`
- 使用 **临时节点**（`EPHEMERAL`），Provider 下线时自动删除

**ZkRegistryCenter 实现**：
```java
@Override
public void register(String service, String instance) {
    String path = buildPath(service, instance);
    client.create()
            .creatingParentsIfNeeded()
            .withMode(CreateMode.EPHEMERAL)
            .forPath(path);
}

@Override
public void subscribe(String service, ChangeListener listener) {
    TreeCache cache = TreeCache.newBuilder(client, buildServicePath(service)).build();
    cache.getListenable().addListener((c, event) -> {
        listener.onChange(fetchAll(service));
    });
    cache.start();
}
```

### 4. 负载均衡

**接口定义**：
```java
public interface LoadBalancer {
    String choose(List<String> instances);
}
```

**实现策略**：
- **RoundRobinLoadBalancer**：轮询，使用 `AtomicInteger` 计数器，线程安全
- **RandomLoadBalancer**：随机，使用 `Random.nextInt()`

**Consumer 集成**：
```java
// ConsumerBootstrap 创建代理时传入 Supplier<String>
return (T) Proxy.newProxyInstance(
    iface.getClassLoader(),
    new Class[]{iface},
    new MarpcInvocationHandler(iface, () -> {
        List<String> instances = serviceInstances.get(service);
        return loadBalancer.choose(instances);
    })
);
```

每次 RPC 调用时，`MarpcInvocationHandler` 通过 `instanceSupplier.get()` 动态选取实例，支持实例列表热更新。

### 5. 服务订阅与动态刷新

**流程**：
1. Consumer 启动时调用 `registryCenter.fetchAll(service)` 获取初始实例列表
2. 调用 `registryCenter.subscribe(service, listener)` 订阅变更
3. Provider 上下线时，Zookeeper 触发 `TreeCache` 监听器
4. `ConsumerBootstrap` 收到回调，更新 `serviceInstances` Map
5. 下次 RPC 调用时，负载均衡器从最新实例列表中选取

```java
List<String> instances = registryCenter.fetchAll(service);
serviceInstances.put(service, instances);
registryCenter.subscribe(service, newInstances -> {
    log.info("服务实例变更: {} -> {}", service, newInstances);
    serviceInstances.put(service, newInstances);
});
```

## 配置说明

**application.properties**：
```properties
# Zookeeper 注册中心地址
marpc.zk.address=localhost:2181
# 应用标识和环境
marpc.app=marpc-app
marpc.env=dev
# 本机对外暴露的地址（Consumer 通过注册中心发现）
marpc.provider.instance=localhost:8080
# 负载均衡策略：roundrobin | random
marpc.loadbalancer=roundrobin
```

**MarpcConfig Bean 配置**：
```java
@Bean
public RegistryCenter registryCenter() {
    ZkRegistryCenter rc = new ZkRegistryCenter(zkAddress, app, env);
    rc.start();
    return rc;
}

@Bean
public LoadBalancer loadBalancer() {
    if ("random".equalsIgnoreCase(lbStrategy)) {
        return new RandomLoadBalancer();
    }
    return new RoundRobinLoadBalancer();
}

@Bean
public ProviderBootstrap providerBootstrap(ApplicationContext context, RegistryCenter registryCenter) {
    return new ProviderBootstrap(context, registryCenter, providerInstance);
}

@Bean
public ConsumerBootstrap consumerBootstrap(ApplicationContext context,
                                           RegistryCenter registryCenter,
                                           LoadBalancer loadBalancer) {
    return new ConsumerBootstrap(context, registryCenter, loadBalancer);
}
```

## 测试方法

### 单元测试

**ProviderBootstrapV2Test**：验证核心功能，不依赖 Spring 容器。

```java
@Test
void hello_twoArgs_overloadDistinguished() {
    RpcResponse resp = bootstrap.invoke(req("hello@2_java.lang.String_int", "hello", "hi", 3));
    assertTrue(resp.isStatus());
    assertEquals("hi hi hi", resp.getData());
}

@Test
void add_intArgs_typeConvertedCorrectly() {
    RpcResponse resp = bootstrap.invoke(req("add@2_int_int", "add", 10, 20));
    assertTrue(resp.isStatus());
    assertEquals(30, ((Number) resp.getData()).intValue());
}

@Test
void list_returnsCorrectList() {
    RpcResponse resp = bootstrap.invoke(req("list@2_java.lang.String_int", "list", "item-", 3));
    assertTrue(resp.isStatus());
    assertEquals(List.of("item-0", "item-1", "item-2"), resp.getData());
}

@Test
void roundRobin_distributeEvenly() {
    var lb = new RoundRobinLoadBalancer();
    List<String> instances = List.of("a", "b", "c");
    assertEquals("a", lb.choose(instances));
    assertEquals("b", lb.choose(instances));
    assertEquals("c", lb.choose(instances));
    assertEquals("a", lb.choose(instances)); // 轮回
}
```

### 集成测试

**前置条件**：启动 Zookeeper（`docker run -d -p 2181:2181 zookeeper`）

**步骤**：
1. 启动 Provider 应用（端口 8080）
2. 启动 Consumer 应用（或同进程）
3. 观察日志：
   ```
   [ProviderBootstrap] 注册服务: com.malinghan.marpc.demo.HelloService -> localhost:8080
   [ConsumerBootstrap] 服务实例变更: com.malinghan.marpc.demo.HelloService -> [localhost:8080]
   ```
4. 调用服务：
   ```java
   @MarpcConsumer
   private HelloService helloService;

   helloService.hello("world");           // "hello, world"
   helloService.hello("hi", 3);           // "hi hi hi"
   helloService.add(10, 20);              // 30
   helloService.list("item-", 3);         // ["item-0", "item-1", "item-2"]
   helloService.getUser(42);              // User(id=42, name="user-42")
   ```

**多实例测试**：
1. 启动 Provider-1（8080）、Provider-2（8081）
2. 修改配置：
   ```properties
   # Provider-2
   marpc.provider.instance=localhost:8081
   ```
3. Consumer 日志显示：
   ```
   [ConsumerBootstrap] 服务实例变更: ... -> [localhost:8080, localhost:8081]
   ```
4. 连续调用，观察负载均衡效果（轮询：8080 -> 8081 -> 8080...）

## 核心原理

### 方法签名匹配流程

```
Consumer                                Provider
   |                                       |
   |-- Method.getParameterTypes() ------->|
   |   [String.class, int.class]          |
   |                                       |
   |-- buildMethodSign() ----------------->|
   |   "hello@2_java.lang.String_int"     |
   |                                       |
   |-- RpcRequest.setMethodSign() -------->|
   |                                       |
   |                                       |-- findMethod(clazz, sign)
   |                                       |   遍历所有方法，匹配签名
   |                                       |
   |                                       |-- convertArgs(method, args)
   |                                       |   JSON.to(paramType, arg)
   |                                       |
   |                                       |-- ReflectionUtils.invokeMethod()
   |<----- RpcResponse.ok(result) --------|
```

### 注册中心交互流程

```
Provider                    Zookeeper                    Consumer
   |                           |                            |
   |-- start() --------------->|                            |
   |   register(HelloService)  |                            |
   |   /marpc-app_dev_...      |                            |
   |   └─ localhost_8080       |                            |
   |   (EPHEMERAL 临时节点)     |                            |
   |                           |                            |
   |                           |<---- start() --------------|
   |                           |   fetchAll(HelloService)   |
   |                           |---- [localhost:8080] ----->|
   |                           |                            |
   |                           |<---- subscribe() ----------|
   |                           |   TreeCache 监听           |
   |                           |                            |
   |-- stop() ---------------->|                            |
   |   unregister()            |                            |
   |   (临时节点自动删除)        |                            |
   |                           |---- onChange([]) --------->|
   |                           |   实例列表变更通知          |
```

### 负载均衡选择流程

```
Consumer 调用                  ConsumerBootstrap              LoadBalancer
   |                                |                            |
   |-- helloService.hello() ------->|                            |
   |                                |                            |
   |                                |-- instanceSupplier.get() ->|
   |                                |   serviceInstances.get()   |
   |                                |   [8080, 8081, 8082]       |
   |                                |                            |
   |                                |<---- choose(instances) ----|
   |                                |   RoundRobin: counter++    |
   |                                |   return instances[idx]    |
   |                                |                            |
   |<----- http://8081/marpc -------|                            |
   |   POST RpcRequest              |                            |
```

## v1.0 -> v2.0 升级要点

| 变更点 | v1.0 | v2.0 |
|--------|------|------|
| 方法匹配 | 名称 + 参数个数 | 方法签名（含类型） |
| 参数类型 | 直接传递 JSON 反序列化结果 | 按方法签名转换为正确类型 |
| 服务发现 | 硬编码 `providerUrl` | Zookeeper 动态注册 |
| 负载均衡 | 单实例 | 轮询/随机多实例 |
| 实例变更 | 不支持 | 订阅 Zookeeper 自动刷新 |
| 构造函数 | `ProviderBootstrap(ctx)` | `ProviderBootstrap(ctx, registry, instance)` |
| 构造函数 | `ConsumerBootstrap(ctx, url)` | `ConsumerBootstrap(ctx, registry, lb)` |
| 构造函数 | `MarpcInvocationHandler(iface, url)` | `MarpcInvocationHandler(iface, instanceSupplier)` |

## 依赖版本

```xml
<dependency>
    <groupId>org.apache.curator</groupId>
    <artifactId>curator-framework</artifactId>
    <version>5.1.0</version>
</dependency>
<dependency>
    <groupId>org.apache.curator</groupId>
    <artifactId>curator-recipes</artifactId>
    <version>5.1.0</version>
</dependency>
```

## 已知限制

- **Zookeeper 单点**：未实现注册中心高可用，生产环境需部署 Zookeeper 集群
- **无健康检查**：依赖 Zookeeper 临时节点，Provider 假死时可能延迟感知
- **无重试机制**：调用失败直接抛异常，未实现自动重试
- **无熔断降级**：无熔断器，故障实例会持续被调用直到从注册中心移除
- **序列化单一**：仅支持 JSON，性能不如 Protobuf/Hessian

## 后续规划（v3.0）

- 重试机制：失败自动重试，支持配置重试次数和间隔
- 熔断器：半开状态恢复，故障实例自动隔离
- 路由策略：灰度发布、按权重路由
- 多协议支持：Netty + 自定义二进制协议
- 监控埋点：调用耗时、成功率、QPS 统计
